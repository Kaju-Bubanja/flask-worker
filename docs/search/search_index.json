{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Flask-Worker Flask-Worker simplifies interaction with a Redis Queue for executing long-running tasks in a Flask application. Long-running tasks are managed by a Worker, who sends the client a loading page until it completes the task. Upon completing the task, the Worker automatically replaces the client's window with the loaded page. Why Flask-Worker Suppose we have a view function which needs to execute a complex task before the client can view the page. What we want is for the complex task to run once, and for the view function to return a loading page while the complex task is running. Our first pass might be: @app.route('/') def index(): complex_task() return 'Complex task finished.' Unfortunately, the view function executes the complex task every time it is called. To make matters worse, the client has no indication that the complex task is in progress. Each time the client tries to refresh the page, the complex task is queued up again. Flask-Worker solves this problem. After setup, we can achieve the desired behavior with. @app.route('/') def index(): worker = Employer.query.first().worker if not worker.job_finished: return worker() return 'Complex task finished' Installation $ pip install flask-worker Citation @software{bowen2020flask-worker, author = {Dillon Bowen}, title = {Flask-Worker}, url = {https://dsbowen.github.io/flask-worker/}, date = {2020-06-11}, } License Users must cite this package in any publications which use it. It is licensed with the MIT License .","title":"Home"},{"location":"#flask-worker","text":"Flask-Worker simplifies interaction with a Redis Queue for executing long-running tasks in a Flask application. Long-running tasks are managed by a Worker, who sends the client a loading page until it completes the task. Upon completing the task, the Worker automatically replaces the client's window with the loaded page.","title":"Flask-Worker"},{"location":"#why-flask-worker","text":"Suppose we have a view function which needs to execute a complex task before the client can view the page. What we want is for the complex task to run once, and for the view function to return a loading page while the complex task is running. Our first pass might be: @app.route('/') def index(): complex_task() return 'Complex task finished.' Unfortunately, the view function executes the complex task every time it is called. To make matters worse, the client has no indication that the complex task is in progress. Each time the client tries to refresh the page, the complex task is queued up again. Flask-Worker solves this problem. After setup, we can achieve the desired behavior with. @app.route('/') def index(): worker = Employer.query.first().worker if not worker.job_finished: return worker() return 'Complex task finished'","title":"Why Flask-Worker"},{"location":"#installation","text":"$ pip install flask-worker","title":"Installation"},{"location":"#citation","text":"@software{bowen2020flask-worker, author = {Dillon Bowen}, title = {Flask-Worker}, url = {https://dsbowen.github.io/flask-worker/}, date = {2020-06-11}, }","title":"Citation"},{"location":"#license","text":"Users must cite this package in any publications which use it. It is licensed with the MIT License .","title":"License"},{"location":"employer_worker/","text":"Employers and workers Flask-Worker uses what I call an 'Employer-Worker' model. An Employer is a class which needs to execute a complex (i.e. long-running) task before a view function returns a page to the client. A Worker executes the Employer's complex task by sending it to a Redis queue. While the client is waiting for the complex task to finish, the Worker sends the client a loading page. We'll create the Employer and Worker models in a file called models.py . Our folder now looks like: factory.py models.py from factory import db from flask_worker import WorkerMixin class Employer(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String) # add a worker to the employer # the worker must reference its employer with an `employer` attribute worker = db.relationship('Worker', uselist=False, backref='employer') def __init__(self, name): self.name = name # instantiate a worker self.worker = Worker().set_method('complex_task', seconds=5) def complex_task(self, seconds=5): import time print('Complex task started') for i in range(seconds): print('Progress: {}%'.format(100.0*i/seconds)) time.sleep(1) print('Progress: 100.0%') print('Complex task finished') class Worker(WorkerMixin, db.Model): id = db.Column(db.Integer, primary_key=True) employer_id = db.Column(db.Integer, db.ForeignKey('employer.id')) We'll also define a convenience method at the bottom of this file for database querying. This function returns a model of the type model_class with the specified name . If this model does not yet exist, this function creates it. ... def get_model(model_class, name): model = model_class.query.filter_by(name=name).first() if not model: model = model_class(name=name) db.session.add(model) db.session.flush([model]) return model","title":"Employers and workers"},{"location":"employer_worker/#employers-and-workers","text":"Flask-Worker uses what I call an 'Employer-Worker' model. An Employer is a class which needs to execute a complex (i.e. long-running) task before a view function returns a page to the client. A Worker executes the Employer's complex task by sending it to a Redis queue. While the client is waiting for the complex task to finish, the Worker sends the client a loading page. We'll create the Employer and Worker models in a file called models.py . Our folder now looks like: factory.py models.py from factory import db from flask_worker import WorkerMixin class Employer(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String) # add a worker to the employer # the worker must reference its employer with an `employer` attribute worker = db.relationship('Worker', uselist=False, backref='employer') def __init__(self, name): self.name = name # instantiate a worker self.worker = Worker().set_method('complex_task', seconds=5) def complex_task(self, seconds=5): import time print('Complex task started') for i in range(seconds): print('Progress: {}%'.format(100.0*i/seconds)) time.sleep(1) print('Progress: 100.0%') print('Complex task finished') class Worker(WorkerMixin, db.Model): id = db.Column(db.Integer, primary_key=True) employer_id = db.Column(db.Integer, db.ForeignKey('employer.id')) We'll also define a convenience method at the bottom of this file for database querying. This function returns a model of the type model_class with the specified name . If this model does not yet exist, this function creates it. ... def get_model(model_class, name): model = model_class.query.filter_by(name=name).first() if not model: model = model_class(name=name) db.session.add(model) db.session.flush([model]) return model","title":"Employers and workers"},{"location":"factory/","text":"Application factory Flask-Worker requires a Flask application with three extensions: A Flask-SQLAlchemy database A Flask-SocketIO socket A Flask-Worker manager The cleanest design uses an application factory . We'll store this in a file called factory.py . from flask_worker import Manager from flask import Flask from flask_socketio import SocketIO from flask_sqlalchemy import SQLAlchemy from redis import Redis from rq import Queue import eventlet import os db = SQLAlchemy() eventlet.monkey_patch(socket=True) socketio = SocketIO(asynch_mode='eventlet') # initialize a Manager with the database and socketio manager = Manager(db=db, socketio=socketio) def create_app(): app = Flask(__name__) app.config['SQLALCHEMY_DATABASE_URI'] = ( 'sqlite:///'+os.path.join(os.getcwd(), 'data.db') ) app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False app.redis = Redis.from_url('redis://') app.task_queue = Queue('my-task-queue', connection=app.redis) db.init_app(app) socketio.init_app(app, message_queue='redis://') # initialize the manager with the application manager.init_app(app) return app","title":"Factory"},{"location":"factory/#application-factory","text":"Flask-Worker requires a Flask application with three extensions: A Flask-SQLAlchemy database A Flask-SocketIO socket A Flask-Worker manager The cleanest design uses an application factory . We'll store this in a file called factory.py . from flask_worker import Manager from flask import Flask from flask_socketio import SocketIO from flask_sqlalchemy import SQLAlchemy from redis import Redis from rq import Queue import eventlet import os db = SQLAlchemy() eventlet.monkey_patch(socket=True) socketio = SocketIO(asynch_mode='eventlet') # initialize a Manager with the database and socketio manager = Manager(db=db, socketio=socketio) def create_app(): app = Flask(__name__) app.config['SQLALCHEMY_DATABASE_URI'] = ( 'sqlite:///'+os.path.join(os.getcwd(), 'data.db') ) app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False app.redis = Redis.from_url('redis://') app.task_queue = Queue('my-task-queue', connection=app.redis) db.init_app(app) socketio.init_app(app, message_queue='redis://') # initialize the manager with the application manager.init_app(app) return app","title":"Application factory"},{"location":"img/","text":"Loading image The worker's loading page displays an image while waiting for its complex task to finish. Flask-Worker looks for a loading image named worker_loading.gif in the app's static directory. Our folder looks like: static/ worker_loading.gif factory.py models.py See the API for details on customizing the loading page.","title":"Loading image"},{"location":"img/#loading-image","text":"The worker's loading page displays an image while waiting for its complex task to finish. Flask-Worker looks for a loading image named worker_loading.gif in the app's static directory. Our folder looks like: static/ worker_loading.gif factory.py models.py See the API for details on customizing the loading page.","title":"Loading image"},{"location":"manager/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Manager flask_worker. Manager class flask_worker. Manager ( app=None, **kwargs ) [source] Flask extension which manages workers. The manager tracks an application import path, a redis connection, the application database, and the web socket. These tools will be invoked by workers. Parameters: app : flask.app.Flask or None, default=None Flask application for whose workers the manager is responsible. If the app is passed to the contructor, the manager will be initialized with the application. Otherwise, you must perform the initialization later by calling init_app . **kwargs : You can set the manager's attributes by passing them as keyword arguments. Attributes: app_import : str, default='app.app' Pythonic import path for the Flask application. e.g. if your application object is created in a file path/to/app.py and named my_app , set the app_import to path.to.app.my_app . connection : redis.client.Redis Redis connection for the workers. If not explicitly set, the manager will set the connection attribute to the app's redis attribute. In this case, the app must have a redis connection attribute named redis when the manager is initialized with the application. db : flask_sqlalchemy.SQLAlchemy Database for the flask application. loading_img_blueprint : str or None, default=None Name of the blueprint to which the loading image belongs. If None , the loading image is assumed to be in the app's static directory. loading_img_filename : str, default='worker_loading.gif' Name of the loading image file. This should be in the app's static directory or a blueprint's static directory. loadering_img_src : str Loading image source path, derived from loading_img_blueprint and loading_img_filename . socketio : flask_socketio.SocketIO or None, default=None Socket object through which workers will emit job progress messages. While this argument is not required on initialization, it must be set before the app is run. template : str, default='worker/worker_loading.html' Name of the html template file for the loading page. Flask-Worker provides a default loading template. Methods init_app ( self, app, **kwargs ) [source] Initialize the manager with the application. Parameters: app : flask.app.Flask Flask application for whose workers the manager is responsible. **kwargs : You can set the manager's attributes by passing them as keyword arguments.","title":"Manager"},{"location":"manager/#manager","text":"","title":"Manager"},{"location":"manager/#flask_workermanager","text":"class flask_worker. Manager ( app=None, **kwargs ) [source] Flask extension which manages workers. The manager tracks an application import path, a redis connection, the application database, and the web socket. These tools will be invoked by workers. Parameters: app : flask.app.Flask or None, default=None Flask application for whose workers the manager is responsible. If the app is passed to the contructor, the manager will be initialized with the application. Otherwise, you must perform the initialization later by calling init_app . **kwargs : You can set the manager's attributes by passing them as keyword arguments. Attributes: app_import : str, default='app.app' Pythonic import path for the Flask application. e.g. if your application object is created in a file path/to/app.py and named my_app , set the app_import to path.to.app.my_app . connection : redis.client.Redis Redis connection for the workers. If not explicitly set, the manager will set the connection attribute to the app's redis attribute. In this case, the app must have a redis connection attribute named redis when the manager is initialized with the application. db : flask_sqlalchemy.SQLAlchemy Database for the flask application. loading_img_blueprint : str or None, default=None Name of the blueprint to which the loading image belongs. If None , the loading image is assumed to be in the app's static directory. loading_img_filename : str, default='worker_loading.gif' Name of the loading image file. This should be in the app's static directory or a blueprint's static directory. loadering_img_src : str Loading image source path, derived from loading_img_blueprint and loading_img_filename . socketio : flask_socketio.SocketIO or None, default=None Socket object through which workers will emit job progress messages. While this argument is not required on initialization, it must be set before the app is run. template : str, default='worker/worker_loading.html' Name of the html template file for the loading page. Flask-Worker provides a default loading template.","title":"flask_worker.Manager"},{"location":"manager/#methods","text":"init_app ( self, app, **kwargs ) [source] Initialize the manager with the application. Parameters: app : flask.app.Flask Flask application for whose workers the manager is responsible. **kwargs : You can set the manager's attributes by passing them as keyword arguments.","title":"Methods"},{"location":"router/","text":"Routers The problem Suppose we want a view function to execute a series of function calls. During these function calls, the Employer's complex task is executed. Our first pass might be to add something like the following in app.py . @app.route('/no-router') def no_router(): print('Request for /no-router') return func1('hello world') def func1(hello_world): print(hello_world) return func2('hello moon') def func2(hello_moon): print(hello_moon) employer = get_model(Employer, 'no-router') employer.complex_task(seconds=5) return func3('hello star') def func3(hello_star): print(hello_star) db.session.commit() return 'Function calls finished.' The problem is that the entire series of function calls executes every time this view function is called. Ideally, we want to 'pause' the series of function calls while the complex task is executing. Once the worker has finished its job, we want to pick up where we left off. The solution A Router solves this problem by managing a series of function calls initiated by a view function. The Router tracks function calls and their arguments. It does this by 'bookmarking' its methods with the @set_route decorator. It also has a dedicated method for using a Worker to run an Employer's complex task. We'll put the following code in a router_models.py file. Our folder looks like: static/ worker_loading.gif app.py factory.py models.py router_models.py from factory import db from models import Employer, get_model from flask_worker import RouterMixin, set_route # create a Router class with the router mixin. class Router(RouterMixin, db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String) def __init__(self, name): self.name = name # set `current_route` on initialization self.current_route = 'func1' self.args = ['hello world'] super().__init__() def func1(self, hello_world): print(hello_world) return self.func2('hello moon') # 'bookmark' functions with the `@set_route` decorator @set_route def func2(self, hello_moon): print(hello_moon) employer = get_model(Employer, 'basic_routing') worker = employer.worker # run the Employer's complex task with a Worker return self.run_worker(worker, self.func3, 'hello star') @set_route def func3(self, hello_star): print(hello_star) return 'Function calls finished.' We'll also create a view function for the Router in app.py . from router_models import Router @app.route('/router') def basic_routing(): print('Request for /router') router = get_model(Router, 'router') return router.route() Resetting a router In the previous example, we bookmarked the final function call. This means that any future calls to this Router will bypass the series of function calls, going straight to the final function call. This is sometimes, but not always, desirable behavior. This example resets the Router. Future calls to this Router will re-execute the entire series of function calls. Add the following to router_models.py . class RouterWithReset(RouterMixin, db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String) def __init__(self, name): self.name = name self.reset() super().__init__() def reset(self): self.current_route = 'func1' self.args, self.kwargs = ['hello world'], {} employer = get_model(Employer, 'routing_with_reset') employer.worker.reset() def func1(self, hello_world): print(hello_world) return self.func2('hello moon') @set_route def func2(self, hello_moon): print(hello_moon) employer = get_model(Employer, 'routing_with_reset') worker = employer.worker return self.run_worker(worker, self.func3, 'hello star') def func3(self, hello_star): print(hello_star) self.reset() return ''' Function calls finished. Reload the page to execute the function calls again. ''' Add the following to app.py . from router_models import RouterWithReset @app.route('/router-reset') def routing_with_reset(): print('Request for /router-reset') router = get_model(RouterWithReset, 'router_reset') return router.route()","title":"Routers"},{"location":"router/#routers","text":"","title":"Routers"},{"location":"router/#the-problem","text":"Suppose we want a view function to execute a series of function calls. During these function calls, the Employer's complex task is executed. Our first pass might be to add something like the following in app.py . @app.route('/no-router') def no_router(): print('Request for /no-router') return func1('hello world') def func1(hello_world): print(hello_world) return func2('hello moon') def func2(hello_moon): print(hello_moon) employer = get_model(Employer, 'no-router') employer.complex_task(seconds=5) return func3('hello star') def func3(hello_star): print(hello_star) db.session.commit() return 'Function calls finished.' The problem is that the entire series of function calls executes every time this view function is called. Ideally, we want to 'pause' the series of function calls while the complex task is executing. Once the worker has finished its job, we want to pick up where we left off.","title":"The problem"},{"location":"router/#the-solution","text":"A Router solves this problem by managing a series of function calls initiated by a view function. The Router tracks function calls and their arguments. It does this by 'bookmarking' its methods with the @set_route decorator. It also has a dedicated method for using a Worker to run an Employer's complex task. We'll put the following code in a router_models.py file. Our folder looks like: static/ worker_loading.gif app.py factory.py models.py router_models.py from factory import db from models import Employer, get_model from flask_worker import RouterMixin, set_route # create a Router class with the router mixin. class Router(RouterMixin, db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String) def __init__(self, name): self.name = name # set `current_route` on initialization self.current_route = 'func1' self.args = ['hello world'] super().__init__() def func1(self, hello_world): print(hello_world) return self.func2('hello moon') # 'bookmark' functions with the `@set_route` decorator @set_route def func2(self, hello_moon): print(hello_moon) employer = get_model(Employer, 'basic_routing') worker = employer.worker # run the Employer's complex task with a Worker return self.run_worker(worker, self.func3, 'hello star') @set_route def func3(self, hello_star): print(hello_star) return 'Function calls finished.' We'll also create a view function for the Router in app.py . from router_models import Router @app.route('/router') def basic_routing(): print('Request for /router') router = get_model(Router, 'router') return router.route()","title":"The solution"},{"location":"router/#resetting-a-router","text":"In the previous example, we bookmarked the final function call. This means that any future calls to this Router will bypass the series of function calls, going straight to the final function call. This is sometimes, but not always, desirable behavior. This example resets the Router. Future calls to this Router will re-execute the entire series of function calls. Add the following to router_models.py . class RouterWithReset(RouterMixin, db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String) def __init__(self, name): self.name = name self.reset() super().__init__() def reset(self): self.current_route = 'func1' self.args, self.kwargs = ['hello world'], {} employer = get_model(Employer, 'routing_with_reset') employer.worker.reset() def func1(self, hello_world): print(hello_world) return self.func2('hello moon') @set_route def func2(self, hello_moon): print(hello_moon) employer = get_model(Employer, 'routing_with_reset') worker = employer.worker return self.run_worker(worker, self.func3, 'hello star') def func3(self, hello_star): print(hello_star) self.reset() return ''' Function calls finished. Reload the page to execute the function calls again. ''' Add the following to app.py . from router_models import RouterWithReset @app.route('/router-reset') def routing_with_reset(): print('Request for /router-reset') router = get_model(RouterWithReset, 'router_reset') return router.route()","title":"Resetting a router"},{"location":"router_mixin/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Routers flask_worker. set_route def flask_worker. set_route ( func ) [source] The @set_route decorator bookmarks the current function call. Specifically, it sets the Router's current_route to the name of the current function and stores the args and kwargs. flask_worker. RouterMixin class flask_worker. RouterMixin ( *args, **kwargs ) [source] Mixin for router models. A router manages a series of function calls initiated by a view function. Among this series of function calls is the employer's complex task. Suppose a view function initiates a series of function calls which include running a Worker. A Router allows the series of function calls to 'pause' while the Worker is running. Once the Worker finishes its job, the Router resumes the series of function calls without repeating earlier functions. Parameters: *args, **kwargs : Passed to super().__init__ . Attributes: current_route : str Name of the current 'route'. A route is one of the router's methods. args : list, default=[] Arguments for the current route, set from the *args parameter. kwargs : dict, default={} Keyword arguments for the current route, set from the **kwargs parameter. Methods route ( self ) [source] Route the request to the current_route . Returns: page_html : str Html of the page returned by the current route. run_worker ( self, worker, next_route, *args, **kwargs ) [source] Run a Worker, and return a call to the next route when finished. Parameters: worker : flask_worker.WorkerMixin Worker whose job should be run. next_route : callable The route which should be run after the worker has finished its job. *args, **kwargs : Arguments and keyword arguments passed to next_route . Returns: page_html : str Html of the page returned by the worker (if the job is not yet ]finished) or the next route function (after the job is finished).","title":"Routers"},{"location":"router_mixin/#routers","text":"","title":"Routers"},{"location":"router_mixin/#flask_workerset_route","text":"def flask_worker. set_route ( func ) [source] The @set_route decorator bookmarks the current function call. Specifically, it sets the Router's current_route to the name of the current function and stores the args and kwargs.","title":"flask_worker.set_route"},{"location":"router_mixin/#flask_workerroutermixin","text":"class flask_worker. RouterMixin ( *args, **kwargs ) [source] Mixin for router models. A router manages a series of function calls initiated by a view function. Among this series of function calls is the employer's complex task. Suppose a view function initiates a series of function calls which include running a Worker. A Router allows the series of function calls to 'pause' while the Worker is running. Once the Worker finishes its job, the Router resumes the series of function calls without repeating earlier functions. Parameters: *args, **kwargs : Passed to super().__init__ . Attributes: current_route : str Name of the current 'route'. A route is one of the router's methods. args : list, default=[] Arguments for the current route, set from the *args parameter. kwargs : dict, default={} Keyword arguments for the current route, set from the **kwargs parameter.","title":"flask_worker.RouterMixin"},{"location":"router_mixin/#methods","text":"route ( self ) [source] Route the request to the current_route . Returns: page_html : str Html of the page returned by the current route. run_worker ( self, worker, next_route, *args, **kwargs ) [source] Run a Worker, and return a call to the next route when finished. Parameters: worker : flask_worker.WorkerMixin Worker whose job should be run. next_route : callable The route which should be run after the worker has finished its job. *args, **kwargs : Arguments and keyword arguments passed to next_route . Returns: page_html : str Html of the page returned by the worker (if the job is not yet ]finished) or the next route function (after the job is finished).","title":"Methods"},{"location":"run/","text":"Running the app Make sure you have two terminal windows open, and navigate to your root directory in both. Running Redis In one terminal window, we'll run the Redis Queue . $ rq run my-task-queue In your window, you should see a message like: 15:46:03: Worker rq:worker:e9f2ed95fc3e48429fc3962fe0f0c03b: started, version 1.2.0 15:46:03: *** Listening on my-task-queue... 15:46:03: Cleaning registries for queue: my-task-queue Note that you can change the name of the task queue in the application factory . Running the app In the other terminal window, we'll run the Flask app. $ python app.py In your window, you should see a message like: 15:54:51: Server initialized for eventlet. 15:54:51: * Restarting with stat 15:54:52: Server initialized for eventlet. 15:54:52: * Debugger is active! 15:54:52: * Debugger PIN: 183-643-336 (3516) wsgi starting up on http://127.0.0.1:5000 Viewing the app Navigate to http://localhost:5000 in your browser. Notice the following message in your redis terminal: Complex task started Progress: 0.0% Progress: 20.0% Progress: 40.0% Progress: 60.0% Progress: 80.0% Progress: 100.0% Complex task finished While the complex task is executing, you'll see the loading gif in your browser. After the worker has finished, the page will reload with a 'Complex task finished' message.","title":"Running the app"},{"location":"run/#running-the-app","text":"Make sure you have two terminal windows open, and navigate to your root directory in both.","title":"Running the app"},{"location":"run/#running-redis","text":"In one terminal window, we'll run the Redis Queue . $ rq run my-task-queue In your window, you should see a message like: 15:46:03: Worker rq:worker:e9f2ed95fc3e48429fc3962fe0f0c03b: started, version 1.2.0 15:46:03: *** Listening on my-task-queue... 15:46:03: Cleaning registries for queue: my-task-queue Note that you can change the name of the task queue in the application factory .","title":"Running Redis"},{"location":"run/#running-the-app_1","text":"In the other terminal window, we'll run the Flask app. $ python app.py In your window, you should see a message like: 15:54:51: Server initialized for eventlet. 15:54:51: * Restarting with stat 15:54:52: Server initialized for eventlet. 15:54:52: * Debugger is active! 15:54:52: * Debugger PIN: 183-643-336 (3516) wsgi starting up on http://127.0.0.1:5000","title":"Running the app"},{"location":"run/#viewing-the-app","text":"Navigate to http://localhost:5000 in your browser. Notice the following message in your redis terminal: Complex task started Progress: 0.0% Progress: 20.0% Progress: 40.0% Progress: 60.0% Progress: 80.0% Progress: 100.0% Complex task finished While the complex task is executing, you'll see the loading gif in your browser. After the worker has finished, the page will reload with a 'Complex task finished' message.","title":"Viewing the app"},{"location":"view/","text":"View functions Now we can use the Employer and Worker in our view functions. Setup By default, the Manager expects the Flask application to be an object named app in a file in the root directory called app.py . (You can change this by setting the Manager's app_import attribute). For the tutorial, we'll stick with the default. Our folder looks like: static/ worker_loading.gif app.py factory.py models.py All of the code in this part of the tutorial goes in the app.py file. from factory import create_app, db, socketio from models import Employer, get_model app = create_app() @app.before_first_request def before_first_request(): db.create_all() # VIEW FUNCTIONS GO HERE if __name__ == '__main__': socketio.run(app, debug=True) Basic use This is a basic example in which the Employer uses its Worker to execute its complex task. The Worker only sends the Employer's complex task to the Redis Queue once, regardless of how many times the client requests this route. Until the Worker finishes its job, it returns a loading page. The result is cached once the Worker finishes its job, so that future calls to this route will not re-run the complex task. @app.route('/') @app.route('/index') def basic(): print('Request for /index') employer = get_model(Employer, 'index') worker = employer.worker if not worker.job_finished: return worker() return 'Complex task finished.' We are now ready to run our app . Resetting a Worker In this example, we reset the Worker after it has finished its job. This means that future calls to this route will re-run the complex task. @app.route('/reset') def with_reset(): print('Request for /reset') employer = get_model(Employer, 'reset') worker = employer.worker if not worker.job_finished: return worker() worker.reset() db.session.commit() return 'Complex task finished. Reload the page to execute the task again.' Callback routes This example demonstrates how to use a Worker's callback function. By default, when a Worker finishes its job, it issues another call to the current view function. Set the worker's callback attribute to the name of another view function to redirect the client after the Worker finishes its job. @app.route('/callback') def with_callback(): print('Request for /callback') employer = get_model(Employer, 'callback') worker = employer.worker worker.callback = 'callback_route' return worker() @app.route('/callback_route') def callback_route(): print('Request for /callback_route') employer = get_model(Employer, 'callback') worker = employer.worker if not worker.job_finished: return worker() worker.reset() db.session.commit() return 'This is the callback route.'","title":"View functions"},{"location":"view/#view-functions","text":"Now we can use the Employer and Worker in our view functions.","title":"View functions"},{"location":"view/#setup","text":"By default, the Manager expects the Flask application to be an object named app in a file in the root directory called app.py . (You can change this by setting the Manager's app_import attribute). For the tutorial, we'll stick with the default. Our folder looks like: static/ worker_loading.gif app.py factory.py models.py All of the code in this part of the tutorial goes in the app.py file. from factory import create_app, db, socketio from models import Employer, get_model app = create_app() @app.before_first_request def before_first_request(): db.create_all() # VIEW FUNCTIONS GO HERE if __name__ == '__main__': socketio.run(app, debug=True)","title":"Setup"},{"location":"view/#basic-use","text":"This is a basic example in which the Employer uses its Worker to execute its complex task. The Worker only sends the Employer's complex task to the Redis Queue once, regardless of how many times the client requests this route. Until the Worker finishes its job, it returns a loading page. The result is cached once the Worker finishes its job, so that future calls to this route will not re-run the complex task. @app.route('/') @app.route('/index') def basic(): print('Request for /index') employer = get_model(Employer, 'index') worker = employer.worker if not worker.job_finished: return worker() return 'Complex task finished.' We are now ready to run our app .","title":"Basic use"},{"location":"view/#resetting-a-worker","text":"In this example, we reset the Worker after it has finished its job. This means that future calls to this route will re-run the complex task. @app.route('/reset') def with_reset(): print('Request for /reset') employer = get_model(Employer, 'reset') worker = employer.worker if not worker.job_finished: return worker() worker.reset() db.session.commit() return 'Complex task finished. Reload the page to execute the task again.'","title":"Resetting a Worker"},{"location":"view/#callback-routes","text":"This example demonstrates how to use a Worker's callback function. By default, when a Worker finishes its job, it issues another call to the current view function. Set the worker's callback attribute to the name of another view function to redirect the client after the Worker finishes its job. @app.route('/callback') def with_callback(): print('Request for /callback') employer = get_model(Employer, 'callback') worker = employer.worker worker.callback = 'callback_route' return worker() @app.route('/callback_route') def callback_route(): print('Request for /callback_route') employer = get_model(Employer, 'callback') worker = employer.worker if not worker.job_finished: return worker() worker.reset() db.session.commit() return 'This is the callback route.'","title":"Callback routes"},{"location":"worker/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Workers flask_worker. WorkerMixin class flask_worker. WorkerMixin ( template=None, *args, **kwargs ) [source] The worker executes a complex task for its employer using a Redis queue. When called, it enqueues a job (one of its employer's methods specified by method_name ). The worker returns a loading page, specified by its loading_page . When a Redis worker grabs the enqueued job, it executes it with the worker's args and kwargs . After execution, the worker's script replaces the client's window location with a call to its callback view function. Parameters: template : str or None, default=None Name of the html template file for the worker's loading page. If None , the worker will use the manager's loading page template. **kwargs : You can set the worker's attributes by passing them as keyword arguments. Attributes: manager : flask_worker.Manager The worker's manager. method_name : str Name of the employer's method which the worker will execute. args : list, default=[] Arguments which will be passed to the executed method. kwargs : dict, default={} Keyword arguments which will be passed to the executed method. callback : str or None, default=None Name of the view function to which the client will navigate once the worker has finished its job. If None , the current view function is re-called. job_finished : bool, default=False Indicates that the worker has finished its job. job_in_progress : bool, default=False Indicates that the worker has a job in progress. job_id : str Identifier for the worker's job. loading_page : sqlalchemy_mutablesoup.MutableSoup Loading page which will be displayed to the client while the worker performs its job. loading_img : bs4.Tag <img> tag for the loading image. loading_img_src : str Source of the loading image. Methods set_method ( self, method_name, *args, **kwargs ) [source] Set the worker's method_name attribute. Parameters: method_name : str Name of the employer's method which the worker executes. *args, **kwargs : Arguments and keyword arguments for the method. Returns: self : flask_worker.WorkerMixin reset ( self ) [source] Clears the job_finished , job_in_progress , and job_id attributes. Returns: self : flask_worker.WorkerMixin __call__ ( self ) [source] Enqueue the employer's job for execution if it is not enqueued already. Returns: loading_page : str (html) The client's loading page.","title":"Worker"},{"location":"worker/#workers","text":"","title":"Workers"},{"location":"worker/#flask_workerworkermixin","text":"class flask_worker. WorkerMixin ( template=None, *args, **kwargs ) [source] The worker executes a complex task for its employer using a Redis queue. When called, it enqueues a job (one of its employer's methods specified by method_name ). The worker returns a loading page, specified by its loading_page . When a Redis worker grabs the enqueued job, it executes it with the worker's args and kwargs . After execution, the worker's script replaces the client's window location with a call to its callback view function. Parameters: template : str or None, default=None Name of the html template file for the worker's loading page. If None , the worker will use the manager's loading page template. **kwargs : You can set the worker's attributes by passing them as keyword arguments. Attributes: manager : flask_worker.Manager The worker's manager. method_name : str Name of the employer's method which the worker will execute. args : list, default=[] Arguments which will be passed to the executed method. kwargs : dict, default={} Keyword arguments which will be passed to the executed method. callback : str or None, default=None Name of the view function to which the client will navigate once the worker has finished its job. If None , the current view function is re-called. job_finished : bool, default=False Indicates that the worker has finished its job. job_in_progress : bool, default=False Indicates that the worker has a job in progress. job_id : str Identifier for the worker's job. loading_page : sqlalchemy_mutablesoup.MutableSoup Loading page which will be displayed to the client while the worker performs its job. loading_img : bs4.Tag <img> tag for the loading image. loading_img_src : str Source of the loading image.","title":"flask_worker.WorkerMixin"},{"location":"worker/#methods","text":"set_method ( self, method_name, *args, **kwargs ) [source] Set the worker's method_name attribute. Parameters: method_name : str Name of the employer's method which the worker executes. *args, **kwargs : Arguments and keyword arguments for the method. Returns: self : flask_worker.WorkerMixin reset ( self ) [source] Clears the job_finished , job_in_progress , and job_id attributes. Returns: self : flask_worker.WorkerMixin __call__ ( self ) [source] Enqueue the employer's job for execution if it is not enqueued already. Returns: loading_page : str (html) The client's loading page.","title":"Methods"},{"location":"worker_mixin/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Workers flask_worker. WorkerMixin class flask_worker. WorkerMixin ( template=None, *args, **kwargs ) [source] The worker executes a complex task for its employer using a Redis queue. When called, it enqueues a job (one of its employer's methods specified by method_name ). The worker returns a loading page, specified by its loading_page . When a Redis worker grabs the enqueued job, it executes it with the worker's args and kwargs . After execution, the worker's script replaces the client's window location with a call to its callback view function. Parameters: template : str or None, default=None Name of the html template file for the worker's loading page. If None , the worker will use the manager's loading page template. **kwargs : You can set the worker's attributes by passing them as keyword arguments. Attributes: manager : flask_worker.Manager The worker's manager. method_name : str Name of the employer's method which the worker will execute. args : list, default=[] Arguments which will be passed to the executed method. kwargs : dict, default={} Keyword arguments which will be passed to the executed method. callback : str or None, default=None Name of the view function to which the client will navigate once the worker has finished its job. If None , the current view function is re-called. job_finished : bool, default=False Indicates that the worker has finished its job. job_in_progress : bool, default=False Indicates that the worker has a job in progress. job_id : str Identifier for the worker's job. loading_page : sqlalchemy_mutablesoup.MutableSoup Loading page which will be displayed to the client while the worker performs its job. loading_img : bs4.Tag <img> tag for the loading image. loading_img_src : str Source of the loading image. Methods set_method ( self, method_name, *args, **kwargs ) [source] Set the worker's method_name attribute. Parameters: method_name : str Name of the employer's method which the worker executes. *args, **kwargs : Arguments and keyword arguments for the method. Returns: self : flask_worker.WorkerMixin reset ( self ) [source] Clears the job_finished , job_in_progress , and job_id attributes. Returns: self : flask_worker.WorkerMixin __call__ ( self ) [source] Enqueue the employer's job for execution if it is not enqueued already. Returns: loading_page : str (html) The client's loading page.","title":"Workers"},{"location":"worker_mixin/#workers","text":"","title":"Workers"},{"location":"worker_mixin/#flask_workerworkermixin","text":"class flask_worker. WorkerMixin ( template=None, *args, **kwargs ) [source] The worker executes a complex task for its employer using a Redis queue. When called, it enqueues a job (one of its employer's methods specified by method_name ). The worker returns a loading page, specified by its loading_page . When a Redis worker grabs the enqueued job, it executes it with the worker's args and kwargs . After execution, the worker's script replaces the client's window location with a call to its callback view function. Parameters: template : str or None, default=None Name of the html template file for the worker's loading page. If None , the worker will use the manager's loading page template. **kwargs : You can set the worker's attributes by passing them as keyword arguments. Attributes: manager : flask_worker.Manager The worker's manager. method_name : str Name of the employer's method which the worker will execute. args : list, default=[] Arguments which will be passed to the executed method. kwargs : dict, default={} Keyword arguments which will be passed to the executed method. callback : str or None, default=None Name of the view function to which the client will navigate once the worker has finished its job. If None , the current view function is re-called. job_finished : bool, default=False Indicates that the worker has finished its job. job_in_progress : bool, default=False Indicates that the worker has a job in progress. job_id : str Identifier for the worker's job. loading_page : sqlalchemy_mutablesoup.MutableSoup Loading page which will be displayed to the client while the worker performs its job. loading_img : bs4.Tag <img> tag for the loading image. loading_img_src : str Source of the loading image.","title":"flask_worker.WorkerMixin"},{"location":"worker_mixin/#methods","text":"set_method ( self, method_name, *args, **kwargs ) [source] Set the worker's method_name attribute. Parameters: method_name : str Name of the employer's method which the worker executes. *args, **kwargs : Arguments and keyword arguments for the method. Returns: self : flask_worker.WorkerMixin reset ( self ) [source] Clears the job_finished , job_in_progress , and job_id attributes. Returns: self : flask_worker.WorkerMixin __call__ ( self ) [source] Enqueue the employer's job for execution if it is not enqueued already. Returns: loading_page : str (html) The client's loading page.","title":"Methods"}]}